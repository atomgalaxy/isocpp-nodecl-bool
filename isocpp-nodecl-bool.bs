<pre class='metadata'>
Title: Nodecl(bool) Hides your Friends, Hides your Wife
Status: P
Audience: CWG
Editor: Gašper Ažman <gasper.azman@gmail.com>
Editor: Timur Daumner <>
Editor: Christopher DiBella <>
Editor: Phil Nash <>
Shortname: PXXXX
Abstract: how to hide your friends and define them too.
Group: WG21
Date: 2019-04-01
Markup Shorthands: markdown yes
Revision: 0
ED: https://github.com/atomgalaxy/using-enum/using-enum.bs
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

Revision History {#history}
================

Status of this paper {#status}
====================



Motivation {#motivation}
==========

Hidden friends -- or inline friend definitions -- are a great way to overload operators, because it
means that they can't be found by regular name look-up rules. For example:

```cpp
class widget_one {
public:
   widget_one() = default;

   constexpr explicit widget_one(int x) noexcept
      : x_{x}
   {}
private:
   int x_ = 0;

   friend constexpr bool operator==(widget_one const x, widget_one const y) noexcept
   { return x.x_ == y.x_; }

   friend constexpr bool operator!=(widget_one const x, widget_one const y) noexcept
   { return not (x == y); }
};

class widget_two {
public:
   widget_two() = default;

   constexpr explicit widget_two(int x) noexcept
      : x_{x}
   {}

   constexpr bool operator==(widget_two const other) noexcept
   { return x_ == other.x_; }

   constexpr bool operator!=(widget_two const other) noexcept
   { return not (*this == other); }
private:
   int x_ = 0;
};
```

Proposed Wording {#wording}
===========================

Acknowledgements {#ack}
================


<!--
 vim: ft=markdown wrap linebreak nolist textwidth=0 wrapmargin=0
-->
