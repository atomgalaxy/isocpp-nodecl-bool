<pre class='metadata'>
Title: Nodecl(bool) - An Independance of Declarations
Status: P
Audience: CWG
Editor: Gašper Ažman <gasper.azman@gmail.com>
Editor: Timur Doumler <papers@timur.audio>
Editor: Christopher DiBella <>
Editor: Phil Nash <isocpp@philnash.me>
Shortname: PXXXX
Abstract: how to hide your friends and define them too.
Group: WG21
Date: 2019-04-01
Markup Shorthands: markdown yes
Revision: 0
ED: https://atomgalaxy.github.io/isocpp-nodecl-bool/isocpp-nodecl-bool.html
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

Revision History {#history}
================

0. Initial version!


Status of this paper {#status}
====================

This paper defines an out-of-standard extension to C++23.


Motivation {#motivation}
==========

Hidden friends -- or inline friend definitions -- are a great way to overload operators, because it
means that they can't be found by regular name look-up rules (qualified or unqualified). For example:

```cpp
#include <iostream>

namespace example {
  struct A {
      friend std::ostream& operator<<(std::ostream& o, A const& x) noexcept;

    private:
      int x_ = 0;
  };

  // public streaming operator
  std::ostream& operator<<(std::ostream& o, A const& x) noexcept {
    return o << "A(" << x.x_ << ")";
  }

 struct B {
    // public streaming operator, but ADL-only.
    friend std::ostream& operator<<(std::ostream& o, B const& x) noexcept {
      return o << "B(" << x.x_ << ")";
    }

   private:
     int x_ = 0;
 };
} // namespace example

int main()
{
  Function pointer type for operator<<s
  using StreamA = std::ostream&(*)(std::ostream&, example::A const&);
  using StreamB = std::ostream&(*)(std::ostream&, example::B const&);
  StreamA stream_a = example::operator<<; // works
  StreamB stream_b = example::operator<<; // ERROR: lookup fails because ADL-only.
}
```

This is important for layering. `operator<<` is a customization point (an
*aspect*) for interoperability with the standard streams library. If the
streams library is not in use, the dependency is unwanted; yet,
forward-declaring is insufficient: the definition, not just the declaration, of
the hidden friend must appear in-line.

If the definition appears out-of-line, it adds a declaration to the namespace
(as evidenced by `A`), which means the operator can then be found by
non-argument dependent lookup. In the case of `operator<<`, this is
undesirable, as every class and class template defines one, and so pruning this
large overload set is very slow.

xxxxxxxxxxxxx

The difference between these two types is that `widget_one` has its comparison operators declared,
whereas `widget_two` does not: this is the only occurrence of a declaration that is not a definition
in the whole International Standard. These 'inline friend definitions' that don't have declarations
have a _significant_ advantage over any of the ones that do have declarations: that is, they can
_only_ be found by argument-dependent lookup. This means that they can't be called à la
`two::operator==(widget_two{}, widget_two{})` (`widget_two{} == widget_two{}` is the canonical
usage), and that the overload set for `operator==` is reduced: this means that looking up
`operator==` is heavily reduced -- this lowers the burden on compile-times, because the compiler
doesn't need to consider nearly as many overloads for a type where things don't matter (e.g.
`operator==` for `vector<T>` doesn't need to be considered for `widget_two`!). It may also improve
compiler error messages by reduce noise around name look-up candidate set printouts.

The major drawbacks are that `operator==`:

* is a _friend_ of `widget_two`, yet it does not need to be
so: just as with member functions, functions (and types) should only be friends if they actually
need to interact with the protected or private implementation details. Neither `widget_one`, nor
`widget_two` need to interact with the implementation details (as demonstrated by `widget_one`).
* must be written inline within the class declaration since adding a declaration for the function
makes it findable by normal (non-ADL) lookup rules.

Since there's no way to define a function that is not also a declaration, we're in a bind: do we use
this 'hidden friend' definition to make operators only findable by ADL, or do we declare them
instead, and restrict what they can access?

We would live all the advantages - with none of the drawbacks - and so we propose a new specifier, 
herein called `nodecl`, which allows us to indicate that a function should not have a declaration that is visible
during overload resolution.

Example usage:

```cpp
namespace three {
   class widget_three {
   public:
      widget_three() = default;

      constexpr explicit widget_three(int x) noexcept
         : x_{x}
      {}

      constexpr int x() const noexcept
      { return x_; }
   private:
      int x_ = 0;
   };

   constexpr bool operator==(widget_three const x, widget_three const y) noexcept nodecl
      { return x.x() == y.x(); }

   constexpr bool operator!=(widget_three const x, widget_three const y) noexcept nodecl
   { return not (x == y); }
} // namespace three
```

Both `operator==` and `operator!=` in this third namespace are function definitions that _do not_
have declarations. The `nodecl` specifier is a context-sensitive keyword (hence why it is on the RHS
of the function definition).

`nodecl` functions may no be defined outside the associated class and need not be a friend.
You may also write a separate declaration and definition - it's just that the declaraton will not be visibke during overload resolution.

Besides operators, `nodecl` could be useful for overloads of `swap`, `iter_swap`, and `iter_move`.

Proposed Wording {#wording}
===========================

In [dcl.decl], modify paragraph 5 as follows:

_parameters_and_qualifiers_:<br>
&nbsp;&nbsp;&nbsp;&nbsp;( _parameter-declaration-clause_ _<sub>opt</sub>_ ) _cv-qualifier-seq_ _<sub>opt</sub>_ _ref-qualifier_ _<sub>opt</sub>_ _noexcept-specifier_ _<sub>opt</sub>_ <ins>_nodecl-specifier_ _<sub>opt</sub>_</ins> _attribute-specifier-seq_ _<sub>opt</sub>_
<br><br>
<ins>_nodecl-specifier:_</ins><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<ins><tt>nodecl </tt></ins><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<ins><tt>nodecl </tt>( _constant-expression_ )</ins>
 
 Add a new paragraph below as follows:
 
 <ins>
 In a <em>nodecl-specifier</em>, the _constant-expression_, if supplied, shall be a contextually converted constant expression of type <tt>bool</tt>.
 </ins>
 

Acknowledgements {#ack}
================


<!--
 vim: ft=markdown wrap linebreak nolist textwidth=0 wrapmargin=0
-->
