<pre class='metadata'>
Title: Nodecl(bool) - An Independance of Declarations
Status: P
Audience: CWG
Editor: Gašper Ažman <gasper.azman@gmail.com>
Editor: Timur Daumner <>
Editor: Christopher DiBella <>
Editor: Phil Nash <isocpp@philnash.me>
Shortname: PXXXX
Abstract: how to hide your friends and define them too.
Group: WG21
Date: 2019-04-01
Markup Shorthands: markdown yes
Revision: 0
ED: https://atomgalaxy.github.io/isocpp-nodecl-bool/isocpp-nodecl-bool.html
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

Revision History {#history}
================

Status of this paper {#status}
====================

This paper defines an out-of-standard extension to C++23.


Motivation {#motivation}
==========

Hidden friends -- or inline friend definitions -- are a great way to overload operators, because it
means that they can't be found by regular name look-up rules (qualified or unqualified). For example:

```cpp
namespace one {
   class widget_one {
   public:
      widget_one() = default;

      constexpr explicit widget_one(int x) noexcept
         : x_{x}
      {}

      constexpr int x() const noexcept
      { return x_; }
   private:
      int x_ = 0;
   };

   constexpr bool operator==(widget_one const x, widget_one const y) noexcept
      { return x.x() == y.x(); }

   constexpr bool operator!=(widget_one const x, widget_one const y) noexcept
   { return not (x == y); }
} // namespace one

namespace two {
   class widget_two {
   public:
      widget_two() = default;

      constexpr explicit widget_two(int x) noexcept
         : x_{x}
      {}

      constexpr int x() const noexcept
      { return x_; }

      friend constexpr bool operator==(widget_two const x, widget_two const y) noexcept
      { return x.x() == y.x(); }

      friend constexpr bool operator!=(widget_two const x, widget_two const y) noexcept
      { return not (x == y); }
   private:
      int x_ = 0;
   };
} // namespace two

int main()
{
   // TODO show that you can't find widget_one operator== isn't findable outside ADL in an easy way
}
```

The difference between these two types is that `widget_one` has its comparison operators declared,
whereas `widget_two` does not: this is the only occurrence of a declaration that is not a definition
in the whole International Standard. These 'inline friend definitions' that don't have declarations
have a _significant_ advantage over any of the ones that do have declarations: that is, they can
_only_ be found by argument-dependent lookup. This means that they can't be called à la
`two::operator==(widget_two{}, widget_two{})` (`widget_two{} == widget_two{}` is the canonical
usage), and that the overload set for `operator==` is reduced: this means that looking up
`operator==` is heavily reduced -- this lowers the burden on compile-times, because the compiler
doesn't need to consider nearly as many overloads for a type where things don't matter (e.g.
`operator==` for `vector<T>` doesn't need to be considered for `widget_two`!). It may also improve
compiler error messages by reduce noise around name look-up candidate set printouts.

The major drawbacks are that `operator==`:

(a) is a _friend_ of `widget_two`, yet it does not need to be
so: just as with member functions, functions (and types) should only be friends if they actually
need to interact with the protected or private implementation details. Neither `widget_one`, nor
`widget_two` need to interact with the implementation details (as demonstrated by `widget_one`).
(b) must be written inline within the class declaration since adding a declaration for the function
makes it findable by normal (non-ADL) lookup rules.

Since there's no way to define a function that is not also a declaration, we're in a bind: do we use
this 'hidden friend' definition to make operators only findable by ADL, or do we declare them
instead, and restrict what they can access?

We would live all the advantages - with none of the drawbacks - and so we propose a new specifier, 
herein called `nodecl`, which allows us to indicate that a function should not have a declaration.

Example usage:

```cpp
namespace three {
   class widget_three {
   public:
      widget_three() = default;

      constexpr explicit widget_three(int x) noexcept
         : x_{x}
      {}

      constexpr int x() const noexcept
      { return x_; }
   private:
      int x_ = 0;
   };

   constexpr bool operator==(widget_three const x, widget_three const y) noexcept nodecl
      { return x.x() == y.x(); }

   constexpr bool operator!=(widget_three const x, widget_three const y) noexcept nodecl
   { return not (x == y); }
} // namespace three
```

Both `operator==` and `operator!=` in this third namespace are function definitions that _do not_
have declarations. The `nodecl` specifier is a context-sensitive keyword (hence why it is on the RHS
of the function definition).

Besides operators, `nodecl` could be useful for overloads of `swap`, `iter_swap`, and `iter_move`.

Proposed Wording {#wording}
===========================

Acknowledgements {#ack}
================


<!--
 vim: ft=markdown wrap linebreak nolist textwidth=0 wrapmargin=0
-->
